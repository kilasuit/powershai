<#
	Uma pequeno dilema meu: Um produto ou serviço só muito bom, se ele consegue suprir as demandas dos próprios criados!
	E, baseado nisso, temos o script AI DOC!
	
	ESte script usa o próprio PowershAI para gerar docs em outros idiomas
	ele é um utilitário para facilitar porta a documentação original para outros idiomas, que ainda não possuem uma tradução revisada por alguém expert no idioma de destino.  
	
	Ele pode ser utilizado sempre que qusier gerar novos arquivos de documentação, ou atualizar existentes.  
	Para manter a qualidade, recomendamos o uso com LLM avançados, como GPT-4o-mini, llam 3.1, ou gemini flash.  
	Importante que o modelo suporte longos contextos!
	
	O script causa atualizações de arquivos no projeto, então, é preciso seguir o fluxo normalmente:
		- commit no git 
		- bump de versão 
		- publicar 
		
	Imagine que este script seja seu assistente de tradução do PowershAI!
	Use e abuse!
#>
param(
	$SourceLang = $null
	,$TargetLang = $null
	,[switch]$KeepProvider
	,$Provider = "openai"
)

$ErrorActionPreference = "Stop";

function JoinPath {
	return ($Args -Join [IO.Path]::DirectorySeparatorChar)
}

function JoinPath {
	return ($Args -Join [IO.Path]::DirectorySeparatorChar)
}

$ProjectRoot = $PSScriptRoot;

write-host "Loading local powershai module";
import-module -force (JoinPath $ProjectRoot powershai)

if(!$SourceLang){
	throw "Must specifuy -SourceLang"
}

if(!$TargetLang){
	throw "Must specifuy -TargetLang"
}

$SourcePath = JoinPath $ProjectRoot docs $SourceLang;
$TargetPath = JoinPath $ProjectRoot docs $TargetLang

if(-not(Test-Path $SourcePath)){
	throw "Invalid Lang: $SourceLang, PathNotfound = $SourcePath";
}

if(-not(Test-Path $TargetPath)){
	throw "Invalid Lang: $TargetLang, PathNotfound = $TargetPath";
}


$TranslationMapFile = JoinPath $TargetPath AiTranslations.json

if(Test-Path $TranslationMapFile){
	$TranslationMap = Get-Content -Raw $TranslationMapFile | ConvertFrom-Json;
} else {
	$TranslationMap = @{}
}

# List all source files!
$SourceFiles = gci -rec (JoinPath $sourcePath *.md)

$NewMap = @{};

if(!$KeepProvider){
	write-host "Enforcing provider $Provider";
	Set-AiProvider $provider;
}




foreach($SrcFile in $SourceFiles){
	
	$SrcRelPath = $SrcFile.FullName.replace($SourcePath,'') -replace '^.',''
	$FileId	= $SrcRelPath.replace('\','/');
	
	$TargetFilePath = JoinPath $TargetPath $SrcRelPath;
	$TargetFile = Get-Item $TargetFilePath -EA SilentlyContinue;
	
	write-host "File: $SrcRelPath";
	
	write-host "	Calculating Hash..."
	$SrcHash = Get-FileHash $SrcFile;
	
	$TranslationInfo = $TranslationMap.$FileId;
	
	$TargetHash = $null
	$FileBackup = $null
	if($TargetFile){
		write-host "	Target exists!"
		$FileBackup = Get-Content $TargetFile;
		
		# check if file is auto updated!
		# aCalculate hash!
		$TargetHash = Get-FileHash $TargetFile	
		
		# Checa se o arquivo foi geraod automaticamente!
		if(!$TranslationInfo){
			write-host "	File not generated by AiDoc! Skipping...";
			continue;
		}
		
		# Get hash!
		$AiHash = $TranslationInfo.TargetHash;
		
		if($AiHash -ne $TargetHash.Hash){
			write-host "	FileChanged. Will not be updated...";
			continue;
		}
		
		# Neste ponto, assume que o arquivo pode ser atualizavel!s
	}
	
	#Atualiza o map!
	#Mesmo que nao haja atualizcoes nessa iteracao, garantimos que os dados serão escrito na proxima vez em que o arquivo de map for atualziado!
	#Se ele nunca for atualizado, então, não tem problema, significa que o valor antigo não foi sobrescrito!
	$NewMap[$FileId] = $TranslationInfo;
	
	# Checa se mudou!
	if($TranslationInfo.SrcHash -eq $SrcHash.Hash){
		write-host "	Nothing changed... Skipping";
		continue;
	}


	write-host "	Translating file...";
	$FileContent = Get-Content -Raw $SrcFile;
	
	# Divide o markdown em blocos, para evitar ultrassar o size do modelo!
	$BlockSize 	= 6000;
	$FullTranslation = "";
	
	$Control = @{
		buffer 		= @()
		TotalChars 	= 0
		text 		= ""
	}
	
	Function Translate {
		$BufferText 		= $Control.buffer -Join "`n";
		$Control.buffer 	= @();
		$Control.TotalChars = 0;
		
		write-host "	Buffer:" $BufferText.length;
		
		$system = @(
			"Traduza o texto do usuário para a linguagem de código $($TargetLang). Retorne APENAS o texto traduzido."
			"Manter o conteúdo original entre <!--! -->. Traduzir comentários de código, nomes de funções de exemplo. Não traduzir nomes de comandos do PowershAI."
		) -Join "`n"
		
		$prompt = @(
			"s: $system"
			$BufferText 
		)
		
		write-host "	Invoking AI..."
		$result = Get-AiChat -prompt $prompt 
		$translated = $result.choices[0].message.content;
		write-host "	Translated: $($translated.length) chars"
		$Control.text += $translated
	}
	
	if($FileContent.length -gt $BlockSize){
		$FileLines = $FileContent -split "`r?`n"
		foreach($line in $FileLines){
			
			$LineLen 	= $Line.length;
			$EstTotal 	= $Control.TotalChars + $LineLen;
			
			if($EstTotal -ge $BlockSize){
				Translate
			}
			
			$Control.buffer += $line;
			$Control.TotalChars += $LineLen;
		}
	} else {
		$Control.buffer = $FileContent;
	}
	
	Translate
	
	$Translated = $Control.text
	write-host "	Translated Length: $($Translated.length)";
	
	write-host "	Creating target directories..."
	$Paths = Split-Path $TargetFilePath -Parent;
	$null = New-Item -ItemType Directory -Path $Paths -force;
	

	
	try {
		write-host "	Updating target content..."
		$Translated | Set-Content -Encoding UTF8 -Path $TargetFilePath
	
		# check if file is auto updated!
		# aCalculate hash!
		$TargetNewHash = Get-FileHash $TargetFilePath	
		
		write-host "	Creating new map..."
		$NewMap[$FileId] = @{
			SrcHash 	= $SrcHash.Hash
			TargetHash	= $TargetNewHash.Hash;
		}
		
		write-host "	Updating $TranslationMapFile";
		$TranslationMapJson = $NewMap | ConvertTo-Json	
		Set-Content -Path $TranslationMapFile -Value $TranslationMapJson
	} catch {
		# Restore file backup!
		if($FileBackup){
			write-warning "	Restoring file backup due to errors..."
			$FileBackup | Set-Content -Encoding UTF8 -Path $TargetFilePath
		}
		
		throw;
	}

		
}















