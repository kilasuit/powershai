<#
	Uma pequeno dilema meu: Um produto ou serviço só muito bom, se ele consegue suprir as demandas dos próprios criados!
	E, baseado nisso, temos o script AI DOC!
	
	ESte script usa o próprio PowershAI para gerar docs em outros idiomas
	ele é um utilitário para facilitar porta a documentação original para outros idiomas, que ainda não possuem uma tradução revisada por alguém expert no idioma de destino.  
	
	Ele pode ser utilizado sempre que qusier gerar novos arquivos de documentação, ou atualizar existentes.  
	Para manter a qualidade, recomendamos o uso com LLM avançados, como GPT-4o-mini, llam 3.1, ou gemini flash.  
	Importante que o modelo suporte longos contextos!
	
	O script causa atualizações de arquivos no projeto, então, é preciso seguir o fluxo normalmente:
		- commit no git 
		- bump de versão 
		- publicar 
		
	Imagine que este script seja seu assistente de tradução do PowershAI!
	Use e abuse!
#>
param(
	$SourceLang = $null
	,$TargetLang = $null
	,[switch]$KeepProvider
	,$Provider = "openai"
	,[switch]$Force
	,$MaxTokens = 8192
	,$FileFilter
)

$ErrorActionPreference = "Stop";

function JoinPath {
	return ($Args -Join [IO.Path]::DirectorySeparatorChar)
}

function JoinPath {
	return ($Args -Join [IO.Path]::DirectorySeparatorChar)
}

$ProjectRoot = $PSScriptRoot;

write-host "Loading local powershai module";
import-module -force (JoinPath $ProjectRoot powershai)

if(!$SourceLang){
	throw "Must specifuy -SourceLang"
}

if(!$TargetLang){
	throw "Must specifuy -TargetLang"
}

$SourcePath = JoinPath $ProjectRoot docs $SourceLang;
$TargetPath = JoinPath $ProjectRoot docs $TargetLang

if(-not(Test-Path $SourcePath)){
	throw "Invalid Lang: $SourceLang, PathNotfound = $SourcePath";
}

if(-not(Test-Path $TargetPath)){
	throw "Invalid Lang: $TargetLang, PathNotfound = $TargetPath";
}


$TranslationMapFile = JoinPath $TargetPath AiTranslations.json

if(Test-Path $TranslationMapFile){
	$TranslationMap = Get-Content -Raw $TranslationMapFile | ConvertFrom-Json;
} else {
	$TranslationMap = @{}
}

# List all source files!
$SourceFiles = gci -rec (JoinPath $sourcePath *.md)



if(!$KeepProvider){
	write-host "Enforcing provider $Provider";
	Set-AiProvider $provider;
}

$CurrentProvider = Get-AiCurrentProvider

write-host "Generating fixed translations..."
$WaterResult = Get-AiChat -prompt @(
	"s: Traduzir para $TargetLang. Rertornar somente o texto traduzido"	
	"Traduzido automaticamente usando o PowershAI e IA"
)


$WatermarkText = $WaterResult.choices[0].message.content

$NewMap = @{}
$TranslationMap.psobject.properties | %{
	$NewMap[$_.name] = $_.Value;
}

$TranslationMap = $NewMap;


foreach($SrcFile in $SourceFiles){
	
	$SrcRelPath = $SrcFile.FullName.replace($SourcePath,'') -replace '^.',''
	$FileId	= $SrcRelPath.replace('\','/');
	
	write-host "File: $SrcRelPath";
	
	if($FileFilter -and $FileId -NotLike $FileFilter -and $SrcRelPath -NotLike $FileFilter ){
		write-host "	Eliminated by filter"
		continue;
	}
	
	$TargetFilePath = JoinPath $TargetPath $SrcRelPath;
	$TargetFile = Get-Item $TargetFilePath -EA SilentlyContinue;
	
	
	
	write-host "	Calculating Hash..."
	$SrcHash = Get-FileHash $SrcFile;
	
	$TranslationInfo = $TranslationMap[$FileId];
	
	if($Force){
		write-host "	### Forcing!":
		$TargetFile = $null
		$TranslationInfo = $null;
	}
	
	$TargetHash = $null
	$FileBackup = $null
	if($TargetFile){
		write-host "	Target exists!"
		$FileBackup = Get-Content $TargetFile;
		
		# check if file is auto updated!
		# aCalculate hash!
		$TargetHash = Get-FileHash $TargetFile	
		
		# Checa se o arquivo foi geraod automaticamente!
		if(!$TranslationInfo){
			write-host "	File not generated by AiDoc! Skipping...";
			continue;
		}
		
		# Get hash!
		$AiHash = $TranslationInfo.TargetHash;
		
		if($AiHash -ne $TargetHash.Hash){
			$TranslationMap.remove($FileId);
			write-host "	FileChanged. Will not be updated more...";
			continue;
		}
		
		# Neste ponto, assume que o arquivo pode ser atualizavel!s
	}
	
	# Checa se mudou!
	if($TranslationInfo.SrcHash -eq $SrcHash.Hash){
		write-host "	Nothing changed... Skipping";
		continue;
	}


	write-host "	Translating file...";
	$FileContent = Get-Content -Raw $SrcFile;
	
	write-host "	Length: $($FileContent.length)";
	
	# Divide o markdown em blocos, para evitar ultrassar o size do modelo!
	$BlockSize 	= $MaxTokens - 1000;
	$FullTranslation = "";
	
	$Control = @{
		buffer 		= @()
		TotalChars 	= 0
		text 		= ""
		blockNum	= 0
		InputTokens = 0
		OutputTokens = 0
		LastModel = $null
	}
	
	Function Translate {
		$BufferText 		= $Control.buffer -Join "`n";
		$Control.buffer 	= @();
		$Control.TotalChars = 0;
		$Control.blockNum++
		
		write-host "	Num: $($Control.blockNum) Buffer:" $BufferText.length;
		
		$Initial = @()

		
		$system = @(
			"Traduza o texto do usuário para a linguagem de código $($TargetLang). Retorne APENAS o texto traduzido."
			"Manter o conteúdo original entre <!--! -->. Traduzir comentários de código, nomes de funções de exemplo. Não traduzir nomes de comandos do PowershAI."
			"Não altere ou complemente partes, foque apenas na tradução do texto."
			$Initial
		) -Join "`n"
		
		$prompt = @(
			"s: $system"
			$BufferText 
		)
		
		write-host "	Invoking AI..."
		$result 	= Get-AiChat -prompt $prompt -MaxTokens $MaxTokens
		$airesult 	= $result.choices[0]
		$usage 		= $result.usage;
		write-host "	Usage: Input = $($usage.prompt_tokens), Output = $($usage.completion_tokens)"
		if($airesult.finish_reason -ne "stop"){
			write-warning "	AIStopREason: $($airesult.finish_reason), this can produce incorrect results!"
		}
		
		$translated = $result.choices[0].message.content;
		write-host "	Translated: $($translated.length) chars"
		$Control.text += $translated
		$Control.InputTokens 	+= $usage.prompt_tokens
		$Control.OutputTokens 	+= $usage.completion_tokens
		$Control.LastModel 		= $result.model;
	}
	
	if($FileContent.length -gt $BlockSize){
		$FileLines = $FileContent -split "`r?`n"
		foreach($line in $FileLines){
			
			$LineLen 	= $Line.length;
			$EstTotal 	= $Control.TotalChars + $LineLen;
			
			if($EstTotal -ge $BlockSize){
				$null = Translate
			}
			
			$Control.buffer += $line;
			$Control.TotalChars += $LineLen;
		}
	} else {
		$Control.buffer = $FileContent;
	}
	
	Translate
	
	$Translated 	= $Control.text
	$InputTokens 	= $Control.InputTokens
	$OutputTokens 	= $Control.OutputTokens
	$Model 			= $Control.LastModel
	write-host "	Translated Length: $($Translated.length)";
	
	write-host "	Creating target directories..."
	$Paths = Split-Path $TargetFilePath -Parent;
	$null = New-Item -ItemType Directory -Path $Paths -force;
	

	
	try {
		write-host "	Updating target content..."
		@(
			$Translated
			''
			''
			'_'+$WatermarkText+'_'
		) | Set-Content -Encoding UTF8 -Path $TargetFilePath
	
		# check if file is auto updated!
		# aCalculate hash!
		$TargetNewHash = Get-FileHash $TargetFilePath	
		
		write-host "	Creating new map..."
		$NewMap[$FileId] = @{
			SrcHash 		= $SrcHash.Hash
			TargetHash		= $TargetNewHash.Hash
			Provider 		= $CurrentProvider.name 
			Model 			= $Model 	
			InputTokens 	= $InputTokens 
			OutputTokens	= $OutputTokens
		}
		
		write-host "	Updating $TranslationMapFile";
		$TranslationMapJson = $TranslationMap | ConvertTo-Json	
		Set-Content -Path $TranslationMapFile -Value $TranslationMapJson
	} catch {
		# Restore file backup!
		if($FileBackup){
			write-warning "	Restoring file backup due to errors..."
			$FileBackup | Set-Content -Encoding UTF8 -Path $TargetFilePath
		}
		
		throw;
	}

		
}















